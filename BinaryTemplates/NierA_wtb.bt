LittleEndian();
char id[4] <hidden=true>;
Assert( Memcmp("WTB\0", id, 4) == 0, "Wrong file type");
FSeek(0);
struct {
	char    id[4]; //WTB\0
	int32   unknown;
	int32   numTex;
	uint32  offsetTextureOffsets <format=hex>;
	uint32  offsetTextureSizes <format=hex>;
	uint32  offsetTextureFlags <format=hex, comment="0x80000000 cube, 0x20000000 alpha, 0x10000000 1bit alpha, 0x3 dummy">;
	uint32  offsetTextureIdx <format=hex>;
	uint32  offsetTextureInfo <format=hex>;
} header;

FSeek( header.offsetTextureOffsets );
uint32  textureOffsets[header.numTex] <format=hex>;

FSeek( header.offsetTextureSizes );
int32  textureSizes[header.numTex] <format=hex>;

FSeek( header.offsetTextureFlags );
uint32  textureFlags[header.numTex] <format=hex, comment="0x20000000 alpha, 0x10000000 1bit alpha, 0x3 dummy">;

if (header.offsetTextureIdx) {
	FSeek( header.offsetTextureIdx );
	uint32 textureIdx[header.numTex] <format=hex>;
}

enum DXGI_FORMAT
{
	DXGI_FORMAT_UNKNOWN = 0x00000000,
	DXGI_FORMAT_R32G32B32A32_TYPELESS = 0x00000001,
	DXGI_FORMAT_R32G32B32A32_FLOAT = 0x00000002,
	DXGI_FORMAT_R32G32B32A32_UINT = 0x00000003,
	DXGI_FORMAT_R32G32B32A32_SINT = 0x00000004,
	DXGI_FORMAT_R32G32B32_TYPELESS = 0x00000005,
	DXGI_FORMAT_R32G32B32_FLOAT = 0x00000006,
	DXGI_FORMAT_R32G32B32_UINT = 0x00000007,
	DXGI_FORMAT_R32G32B32_SINT = 0x00000008,
	DXGI_FORMAT_R16G16B16A16_TYPELESS = 0x00000009,
	DXGI_FORMAT_R16G16B16A16_FLOAT = 0x0000000A,
	DXGI_FORMAT_R16G16B16A16_UNORM = 0x0000000B,
	DXGI_FORMAT_R16G16B16A16_UINT = 0x0000000C,
	DXGI_FORMAT_R16G16B16A16_SNORM = 0x0000000D,
	DXGI_FORMAT_R16G16B16A16_SINT = 0x0000000E,
	DXGI_FORMAT_R32G32_TYPELESS = 0x0000000F,
	DXGI_FORMAT_R32G32_FLOAT = 0x00000010,
	DXGI_FORMAT_R32G32_UINT = 0x00000011,
	DXGI_FORMAT_R32G32_SINT = 0x00000012,
	DXGI_FORMAT_R32G8X24_TYPELESS = 0x00000013,
	DXGI_FORMAT_D32_FLOAT_S8X24_UINT = 0x00000014,
	DXGI_FORMAT_R32_FLOAT_X8X24_TYPELESS = 0x00000015,
	DXGI_FORMAT_X32_TYPELESS_G8X24_UINT = 0x00000016,
	DXGI_FORMAT_R10G10B10A2_TYPELESS = 0x00000017,
	DXGI_FORMAT_R10G10B10A2_UNORM = 0x00000018,
	DXGI_FORMAT_R10G10B10A2_UINT = 0x00000019,
	DXGI_FORMAT_R11G11B10_FLOAT = 0x0000001A,
	DXGI_FORMAT_R8G8B8A8_TYPELESS = 0x0000001B,
	DXGI_FORMAT_R8G8B8A8_UNORM = 0x0000001C,
	DXGI_FORMAT_R8G8B8A8_UNORM_SRGB = 0x0000001D,
	DXGI_FORMAT_R8G8B8A8_UINT = 0x0000001E,
	DXGI_FORMAT_R8G8B8A8_SNORM = 0x0000001F,
	DXGI_FORMAT_R8G8B8A8_SINT = 0x00000020,
	DXGI_FORMAT_R16G16_TYPELESS = 0x00000021,
	DXGI_FORMAT_R16G16_FLOAT = 0x00000022,
	DXGI_FORMAT_R16G16_UNORM = 0x00000023,
	DXGI_FORMAT_R16G16_UINT = 0x00000024,
	DXGI_FORMAT_R16G16_SNORM = 0x00000025,
	DXGI_FORMAT_R16G16_SINT = 0x00000026,
	DXGI_FORMAT_R32_TYPELESS = 0x00000027,
	DXGI_FORMAT_D32_FLOAT = 0x00000028,
	DXGI_FORMAT_R32_FLOAT = 0x00000029,
	DXGI_FORMAT_R32_UINT = 0x0000002A,
	DXGI_FORMAT_R32_SINT = 0x0000002B,
	DXGI_FORMAT_R24G8_TYPELESS = 0x0000002C,
	DXGI_FORMAT_D24_UNORM_S8_UINT = 0x0000002D,
	DXGI_FORMAT_R24_UNORM_X8_TYPELESS = 0x0000002E,
	DXGI_FORMAT_X24_TYPELESS_G8_UINT = 0x0000002F,
	DXGI_FORMAT_R8G8_TYPELESS = 0x00000030,
	DXGI_FORMAT_R8G8_UNORM = 0x00000031,
	DXGI_FORMAT_R8G8_UINT = 0x00000032,
	DXGI_FORMAT_R8G8_SNORM = 0x00000033,
	DXGI_FORMAT_R8G8_SINT = 0x00000034,
	DXGI_FORMAT_R16_TYPELESS = 0x00000035,
	DXGI_FORMAT_R16_FLOAT = 0x00000036,
	DXGI_FORMAT_D16_UNORM = 0x00000037,
	DXGI_FORMAT_R16_UNORM = 0x00000038,
	DXGI_FORMAT_R16_UINT = 0x00000039,
	DXGI_FORMAT_R16_SNORM = 0x0000003A,
	DXGI_FORMAT_R16_SINT = 0x0000003B,
	DXGI_FORMAT_R8_TYPELESS = 0x0000003C,
	DXGI_FORMAT_R8_UNORM = 0x0000003D,
	DXGI_FORMAT_R8_UINT = 0x0000003E,
	DXGI_FORMAT_R8_SNORM = 0x0000003F,
	DXGI_FORMAT_R8_SINT = 0x00000040,
	DXGI_FORMAT_A8_UNORM = 0x00000041,
	DXGI_FORMAT_R1_UNORM = 0x00000042,
	DXGI_FORMAT_R9G9B9E5_SHAREDEXP = 0x00000043,
	DXGI_FORMAT_R8G8_B8G8_UNORM = 0x00000044,
	DXGI_FORMAT_G8R8_G8B8_UNORM = 0x00000045,
	DXGI_FORMAT_BC1_TYPELESS = 0x00000046,
	DXGI_FORMAT_BC1_UNORM = 0x00000047,
	DXGI_FORMAT_BC1_UNORM_SRGB = 0x00000048,
	DXGI_FORMAT_BC2_TYPELESS = 0x00000049,
	DXGI_FORMAT_BC2_UNORM = 0x0000004A,
	DXGI_FORMAT_BC2_UNORM_SRGB = 0x0000004B,
	DXGI_FORMAT_BC3_TYPELESS = 0x0000004C,
	DXGI_FORMAT_BC3_UNORM = 0x0000004D,
	DXGI_FORMAT_BC3_UNORM_SRGB = 0x0000004E,
	DXGI_FORMAT_BC4_TYPELESS = 0x0000004F,
	DXGI_FORMAT_BC4_UNORM = 0x00000050,
	DXGI_FORMAT_BC4_SNORM = 0x00000051,
	DXGI_FORMAT_BC5_TYPELESS = 0x00000052,
	DXGI_FORMAT_BC5_UNORM = 0x00000053,
	DXGI_FORMAT_BC5_SNORM = 0x00000054,
	DXGI_FORMAT_B5G6R5_UNORM = 0x00000055,
	DXGI_FORMAT_B5G5R5A1_UNORM = 0x00000056,
	DXGI_FORMAT_B8G8R8A8_UNORM = 0x00000057,
	DXGI_FORMAT_B8G8R8X8_UNORM = 0x00000058
};
if (header.offsetTextureInfo != 0) {
	FSeek( header.offsetTextureInfo );
	struct {
		DXGI_FORMAT format;
		uint32  data[4];
	} infos[header.numTex];
}

typedef struct ddsPixelFormat_s
{
	int					size;
	int					flags <format=hex>;
	char				id[4];
	int					rgbBitCount;
	int					rBitMask;
	int					gBitMask;
	int					bBitMask;
	int					aBitMask;
} ddsPixelFormat_t <read=ddsPixelFormat_tRead>;
string ddsPixelFormat_tRead( ddsPixelFormat_t &t) {
	string s;
	SPrintf(s, "%s", t.id);
	return s;
}
typedef struct ddsTexHdr_s
{
	BYTE				id[4];
	int					hSize;
	int					flags <format=hex>;
	int					height;
	int					width;
	int					pitchOrLinearSize <format=hex>;
	int					depth;
	int					mipMapCount;
	int					reserved1[11];
	ddsPixelFormat_t	pixelFormat;
	int					caps <format=hex>;
	int					caps2 <format=hex>;
	int					caps3 <format=hex>;
	int					caps4 <format=hex>;
	int					reserved2;
} ddsTexHdr_t;

local int i;
for ( i = 0; i < header.numTex; i++) {
	FSeek(textureOffsets[i]);
	if ( textureSizes[i] > 0 ) {
		struct {
			ddsTexHdr_t header;
			byte data[textureSizes[i]-128];
		} texture;
	} else {
		struct {
		} texture;
	}
}

